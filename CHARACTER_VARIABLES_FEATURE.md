# 🎭 角色变量映射功能

## 功能概述

当Firebase中的剧本在角色网络节点中使用了**角色变量**（如 `{{角色A}}`、`{{角色B}}`），系统会自动检测这些变量，并要求用户为每个变量选择对应的AI角色。后续所有的故事生成和提示词都会自动用实际的AI角色信息替换这些变量。

## 工作流程

### 1. **检测阶段**（后端 + 前端）

**后端服务（scriptService）：**
- `detectCharacterVariables(text)` - 检测单个文本中的变量
- `detectScriptCharacterVariables(script)` - 检测整个剧本中的所有变量

**前端组件（CharacterSelector）：**
- 自动调用检测函数
- 识别 `{{角色A}}`、`{{角色B}}`、`{{角色0}}`、`{{角色1}}` 等格式的变量

### 2. **选择阶段**（前端）

当检测到角色变量时：
- UI自动切换为"角色变量映射"模式
- 为每个检测到的变量显示一个**独立的下拉选择器**
- 用户为每个变量选择对应的AI角色

示例：
```
🎭 请为以下角色变量分配AI角色：

[角色A]
选择AI角色: [▼ 选择一个AI角色]
           ✓ 张三 (MBTI: ENFP)

[角色B]
选择AI角色: [▼ 选择一个AI角色]
           ✓ 李四 (MBTI: ISTJ)
```

### 3. **替换阶段**（后端）

当用户提交选择后：
- 后端接收变量映射：`{ 角色A: character-id-1, 角色B: character-id-2 }`
- 在后续所有操作中自动替换：
  - **故事内容**中的 `{{角色A}}` → 张三，`{{角色B}}` → 李四
  - **系统提示词**中的 `{{角色A}}` → 使用张三的完整信息
  - **用户提示词**中的所有变量 → 使用实际角色信息
  - **提示选项**中的变量 → 替换为实际角色名

## 数据流示例

### Firebase 中的剧本结构
```json
{
  "剧本名": "神秘的邂逅",
  "角色网络": {
    "节点": [
      {
        "姓名": "{{角色A}}",
        "角色简介": "一个神秘的陌生人，由{{角色A}}扮演"
      },
      {
        "姓名": "{{角色B}}",
        "角色简介": "你的老朋友，由{{角色B}}扮演"
      }
    ]
  },
  "角色视角的故事背景": "你在{{角色A}}和{{角色B}}的陪伴下进入了一个...",
  "第一个选择点": "{{角色A}}建议{{角色B}}应该...",
  "预置策略选项": [
    "同意{{角色A}}的想法",
    "支持{{角色B}}的建议",
    "提出自己的意见"
  ]
}
```

### 用户选择
```json
{
  "角色A": "user-ai-char-001", // 选择了 张三
  "角色B": "user-ai-char-002"  // 选择了 李四
}
```

### 处理后的剧本
```json
{
  "角色A": {
    "姓名": "张三",
    "角色简介": "一个神秘的陌生人，由张三扮演"
  },
  "角色B": {
    "姓名": "李四",
    "角色简介": "你的老朋友，由李四扮演"
  },
  "角色视角的故事背景": "你在张三和李四的陪伴下进入了一个...",
  "第一个选择点": "张三建议李四应该...",
  "预置策略选项": [
    "同意张三的想法",
    "支持李四的建议",
    "提出自己的意见"
  ]
}
```

## 技术实现细节

### 前端（Frontend）

**CharacterSelector.tsx 新增功能：**
```typescript
// 1. 检测角色变量
const characterVariables = detectScriptCharacterVariables(script);
const hasCharacterVariables = Object.keys(characterVariables).length > 0;

// 2. 管理变量映射
const [variableMappings, setVariableMappings] = useState<Record<string, string>>({});

// 3. 构建最终映射
const finalCharacterMappings = variableNames.map((varName) => ({
  userAICharacterId: variableMappings[varName],
  scriptRoleId: varName,
  isVariableMapping: true,
}));
```

### 后端（Backend）

**scriptService.ts 新增方法：**
```typescript
// 检测单个文本
detectCharacterVariables(text: string): string[]

// 检测整个剧本
detectScriptCharacterVariables(script: Script): { [key: string]: number }
```

**game.ts 处理流程：**
1. 接收前端的变量映射
2. 识别 `isVariableMapping: true` 标记
3. 在所有后续文本替换中使用变量映射而不是脚本角色信息

## UI 表现

### 当检测到角色变量时

**选择界面：**
- 自动显示"🎭 请为以下角色变量分配AI角色"
- 为每个变量显示紫色高亮的变量名
- 每个变量有独立的下拉选择器
- 实时显示已分配/未分配的进度
- 选择完成后显示绿色勾号和角色名

**例子：**
```
✅ 已分配: 2 / 2 个角色变量

🎭 请为以下角色变量分配AI角色：

[角色A]
选择AI角色：✓ 张三 (MBTI: ENFP)

[角色B]  
选择AI角色：✓ 李四 (MBTI: ISTJ)

[开始游戏] 按钮已启用
```

## 边界情况处理

### 1. 重复的变量
- 如果同一变量出现多次（如多个节点中都有`{{角色A}}`），只需选择一次
- 后续会在所有出现的位置都替换为同一个AI角色

### 2. 混合模式
- 如果剧本**既有**角色变量**又有**固定角色名，只处理变量
- 固定角色不受影响

### 3. 无效变量
- 系统会忽略格式错误的变量（如 `{{角色}}` 没有后缀）
- 只识别 `{{角色A}}`、`{{角色B}}`、`{{角色0}}`、`{{角色1}}` 等格式

### 4. 变量顺序
- 按字母表顺序排列：`角色A` → `角色B` → `角色C` ...
- 按数字顺序排列：`角色0` → `角色1` → `角色2` ...
- 混合时，字母优先

## 使用场景

### ✅ 理想使用场景

1. **模板化剧本**
   - 创建可重用的剧本模板，用变量代替具体角色名
   - 用户可自由组合不同的AI角色

2. **多人互动故事**
   - `{{角色A}}` 和 `{{角色B}}` 代表两个AI角色的互动
   - 用户选择想要的角色组合

3. **通用对话框**
   - 系统提示中包含 `{{角色A}}` 的通用表述
   - 根据用户选择自动填充具体角色信息

## 注意事项

⚠️ **重要：**
- 变量名必须遵循格式：`{{角色X}}` 其中X是 A-J 或 0-9
- 前端和后端的检测逻辑相同，确保一致性
- 用户必须为**所有**检测到的变量都做出选择，才能开始游戏

## 测试检查清单

- [ ] 检测到 `{{角色A}}`、`{{角色B}}` 变量
- [ ] 为每个变量显示独立的选择器
- [ ] 选择后显示正确的角色名
- [ ] 提交后后端能正确替换所有变量
- [ ] 故事内容中的变量被正确替换
- [ ] 系统提示中的变量被正确替换
- [ ] 用户提示中的变量被正确替换
- [ ] 多个相同变量在不同位置都被替换

